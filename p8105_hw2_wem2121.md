Homework 2
================
Wayne Monical wem2121
2024-10-01

``` r
library(tidyverse)
```

    ## ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──
    ## ✔ dplyr     1.1.4     ✔ readr     2.1.5
    ## ✔ forcats   1.0.0     ✔ stringr   1.5.1
    ## ✔ ggplot2   3.5.1     ✔ tibble    3.2.1
    ## ✔ lubridate 1.9.3     ✔ tidyr     1.3.1
    ## ✔ purrr     1.0.2     
    ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
    ## ✖ dplyr::filter() masks stats::filter()
    ## ✖ dplyr::lag()    masks stats::lag()
    ## ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors

``` r
library(readxl)
```

## Problem 1

### Data Cleaning

We begin by importing and cleaning the subway data set. This data set
contains information on the organization, location, and amenities in the
New York city subway system. The data is tidy. The data is consistent,
i.e. each row of the data frame contains information on one subway
entrance or exit. It is structured, i.e. every variable, such as
station, line, and latitude, has its own column. Finally, all values
have their own cell, i.e. there is no value concatenation.

``` r
subway = read_csv(
  "data/NYC_Transit_Subway_Entrance_And_Exit_Data.csv") |> 
  janitor::clean_names()
```

    ## Rows: 1868 Columns: 32
    ## ── Column specification ────────────────────────────────────────────────────────
    ## Delimiter: ","
    ## chr (22): Division, Line, Station Name, Route1, Route2, Route3, Route4, Rout...
    ## dbl  (8): Station Latitude, Station Longitude, Route8, Route9, Route10, Rout...
    ## lgl  (2): ADA, Free Crossover
    ## 
    ## ℹ Use `spec()` to retrieve the full column specification for this data.
    ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.

``` r
subway_cols = c("line", "station_name", "station_latitude", "station_longitude",
                   "route1", "route2", "route3", "route4", "route5", "route6", "route7", 
                   "route8", "route9", "route10", "route11", "entrance_type", "entry",
                   "exit_only", "vending", "ada",    "ada_notes", "entrance_latitude",
                   "entrance_longitude")

subway = subway |> select(all_of(subway_cols))
```

We see here that `entry`, `exit_only`, and `vending` are character
vectors, and `ada` is a logical vector

``` r
logical_vars = c('entry', 'exit_only', 'vending', 'ada')

subway |> 
  select(all_of(logical_vars)) |> 
  summary()
```

    ##     entry            exit_only           vending             ada         
    ##  Length:1868        Length:1868        Length:1868        Mode :logical  
    ##  Class :character   Class :character   Class :character   FALSE:1400     
    ##  Mode  :character   Mode  :character   Mode  :character   TRUE :468

Inspecting the unique values of each character, we can find the
character strings that correspond to each logical value.

``` r
char_vars = c('entry', 'exit_only', 'vending')

for(var in char_vars){
  print(var)
  
  subway |> 
    pull(var) |> 
    unique() |> 
    print()
}
```

    ## [1] "entry"
    ## [1] "YES" "NO" 
    ## [1] "exit_only"
    ## [1] NA    "Yes"
    ## [1] "vending"
    ## [1] "YES" "NO"

Using the `mutate()` function, we can reassign these variables to be
logical based on the character strings that we found.

``` r
subway = subway |> 
  mutate(
    entry = entry == 'YES',
    exit_only = !is.na(exit_only),
    vending = vending == 'YES')
```

There are 465 distinct subway stations.

``` r
subway |> select('station_name', 'line') |> distinct() |> nrow()
```

    ## [1] 465

We must also standardize the route variables as characters.

``` r
subway = subway |> 
  mutate(
    route1 = as.character(route1),
    route2 = as.character(route2),
    route3 = as.character(route3),
    route4 = as.character(route4),
    route5 = as.character(route5),
    route6 = as.character(route6),
    route7 = as.character(route7),
    route8 = as.character(route8),
    route9 = as.character(route9),
    route10 = as.character(route10),
    route11 = as.character(route11),
  )
```

### Q & A

There are 84 ADA compliant subway stations.

``` r
subway |> filter(ada) |> select('station_name', 'line') |> distinct() |> nrow()
```

    ## [1] 84

73% of station entrances and exits without vending allow entrance.

``` r
subway |> filter(!vending) |> pull(exit_only) |> summary()
```

    ##    Mode   FALSE    TRUE 
    ## logical     133      50

``` r
133 / (50 + 133)
```

    ## [1] 0.726776

### Pivoting

Here, we pivot the route variables to a longer format and drop the rows
that do not have a route.

``` r
subway= subway |> 
  pivot_longer(
    route1:route11,
    names_to = 'route_number',
    values_to = 'route'
  ) |> 
  filter(!is.na(route))
```

Using the code below, we find that 17 of the 43 of the stations on the
A, 39%, are ADA compliant.

``` r
subway |> 
  filter(route == 'A') |> 
  select('line', 'station_name', 'ada') |>
  distinct() |> 
  pull(ada) |>
  summary()
```

    ##    Mode   FALSE    TRUE 
    ## logical      43      17

``` r
107 / (166 + 107)
```

    ## [1] 0.3919414

## Problem 2

Here we reading in the 2024 Mr Trash Wheel sheet using the `read_excel`
function. We have specified the excel sheet and the data range, and we
have rounded the number of sports balls and set it to integer values. We
also transform the year variable into an integer.

``` r
mr_trash = 
  read_excel(
    path = 'data/202409 Trash Wheel Collection Data.xlsx',
    sheet = 'Mr. Trash Wheel',
    range = 'A2:N653') |> 
  janitor::clean_names() |> 
  mutate(
    sports_balls = sports_balls |> round() |> as.integer(),
    year = year |> as.integer())
```

Using the same code structure, we can import and clean Gwynnda Trash
Wheel’s data.

``` r
gwyndda_trash = 
  read_excel(
    path = 'data/202409 Trash Wheel Collection Data.xlsx',
    sheet = 'Gwynnda Trash Wheel',
    range = 'A2:K265') |> 
  janitor::clean_names()
```

Adding a variable for `trash_wheel`, we can combine Mr Trash Wheel’s
data with Gwynnda’s data with the `bind_rows` function, stacking the
rows on top of each other. Note that there are some differences between
the two data sets. For example, Gwynnda Trash Wheel has no
`sports_balls` variable, so this variable is `NA` in Gwynnda’s rows.

``` r
mr_trash = mr_trash |> mutate(trash_wheel = 'mr_trash')

gwyndda_trash = gwyndda_trash |> mutate(trash_wheel = 'gwynnda')

trash = bind_rows(mr_trash, gwyndda_trash)
```

What was the total weight collected by Mr. Trash Wheel?

From 2014 to 2024, Mr. Trash Wheel collected a total of 2091 tons of
trash.

``` r
trash |> filter(trash_wheel == 'mr_trash') |> pull(weight_tons) |> sum()
```

    ## [1] 2091.18

By filtering for bins collected by Gwynnda in June of 2022, we can find
that she collected a total of over 1.8^{4} cigarette butts.

``` r
trash |> 
  filter(
    trash_wheel == 'gwynnda',
    year == 2022,
    month == 'June') |> 
  pull(cigarette_butts) |> sum()
```

    ## [1] 18120

How many cigarette butts did Gwynnda collect in June 2022?

``` r
head(trash)
```

    ## # A tibble: 6 × 15
    ##   dumpster month  year date                weight_tons volume_cubic_yards
    ##      <dbl> <chr> <dbl> <dttm>                    <dbl>              <dbl>
    ## 1        1 May    2014 2014-05-16 00:00:00        4.31                 18
    ## 2        2 May    2014 2014-05-16 00:00:00        2.74                 13
    ## 3        3 May    2014 2014-05-16 00:00:00        3.45                 15
    ## 4        4 May    2014 2014-05-17 00:00:00        3.1                  15
    ## 5        5 May    2014 2014-05-17 00:00:00        4.06                 18
    ## 6        6 May    2014 2014-05-20 00:00:00        2.71                 13
    ## # ℹ 9 more variables: plastic_bottles <dbl>, polystyrene <dbl>,
    ## #   cigarette_butts <dbl>, glass_bottles <dbl>, plastic_bags <dbl>,
    ## #   wrappers <dbl>, sports_balls <int>, homes_powered <dbl>, trash_wheel <chr>
