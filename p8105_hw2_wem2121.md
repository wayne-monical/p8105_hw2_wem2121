Homework 2
================
Wayne Monical wem2121
2024-10-01

``` r
library(tidyverse)
```

    ## ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──
    ## ✔ dplyr     1.1.4     ✔ readr     2.1.5
    ## ✔ forcats   1.0.0     ✔ stringr   1.5.1
    ## ✔ ggplot2   3.5.1     ✔ tibble    3.2.1
    ## ✔ lubridate 1.9.3     ✔ tidyr     1.3.1
    ## ✔ purrr     1.0.2     
    ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
    ## ✖ dplyr::filter() masks stats::filter()
    ## ✖ dplyr::lag()    masks stats::lag()
    ## ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors

## Problem 1

We begin by importing and cleaning the subway data set. This data set
contains information on the organization, location, and amenities in the
New York city subway system. The data is tidy. The data is consistent,
i.e. each row of the data frame contains information on one subway
entrance or exit. It is structured, i.e. every variable, such as
station, line, and latitude, has its own column. Finally, all values
have their own cell, i.e. there is no value concatenation.

``` r
subway = read_csv(
  "data/NYC_Transit_Subway_Entrance_And_Exit_Data.csv") |> 
  janitor::clean_names()
```

    ## Rows: 1868 Columns: 32
    ## ── Column specification ────────────────────────────────────────────────────────
    ## Delimiter: ","
    ## chr (22): Division, Line, Station Name, Route1, Route2, Route3, Route4, Rout...
    ## dbl  (8): Station Latitude, Station Longitude, Route8, Route9, Route10, Rout...
    ## lgl  (2): ADA, Free Crossover
    ## 
    ## ℹ Use `spec()` to retrieve the full column specification for this data.
    ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.

``` r
subway_cols = c("line", "station_name", "station_latitude", "station_longitude",
                   "route1", "route2", "route3", "route4", "route5", "route6", "route7", 
                   "route8", "route9", "route10", "route11", "entrance_type", "entry",
                   "exit_only", "vending", "ada",    "ada_notes", "entrance_latitude",
                   "entrance_longitude")

subway = subway |> select(all_of(subway_cols))
```

We see here that `entry`, `exit_only`, and `vending` are character
vectors, and `ada` is a logical vector

``` r
logical_vars = c('entry', 'exit_only', 'vending', 'ada')

subway |> 
  select(all_of(logical_vars)) |> 
  summary()
```

    ##     entry            exit_only           vending             ada         
    ##  Length:1868        Length:1868        Length:1868        Mode :logical  
    ##  Class :character   Class :character   Class :character   FALSE:1400     
    ##  Mode  :character   Mode  :character   Mode  :character   TRUE :468

Inspecting the unique values of each character, we can find the
character strings that correspond to each logical value.

``` r
char_vars = c('entry', 'exit_only', 'vending')

for(var in char_vars){
  print(var)
  
  subway |> 
    pull(var) |> 
    unique() |> 
    print()
}
```

    ## [1] "entry"
    ## [1] "YES" "NO" 
    ## [1] "exit_only"
    ## [1] NA    "Yes"
    ## [1] "vending"
    ## [1] "YES" "NO"

Using the `mutate()` function, we can reassign these variables to be
logical based on the character strings that we found.

``` r
subway = subway |> 
  mutate(
    entry = entry == 'YES',
    exit_only = !is.na(exit_only),
    vending = vending == 'YES')
```

There are 465 distinct subway stations.

``` r
subway |> select('station_name', 'line') |> distinct() |> nrow()
```

    ## [1] 465
